from copy import deepcopy
from collections import deque

# definition of the problem
class Symmetry_puzzle:

    def __init__(self, board, move_history=[]):
        # board(list[list[int]]) - the state of the board
        # move_history(list[list[list[int]]]) - the history of the moves up until this state
        self.board = deepcopy(board)
        (self.blank_row, self.blank_col) = self.find_blank()

        # create an empty array and append move_history
        self.move_history = [] + move_history + [self.board]

    def children(self):
        # returns the possible moves
        functions = [self.add_circle,self.add_square,self.add_triangle]

        children = []
        for func in functions:
            child = func()
            if child:
                children.append(child)

        return children

    def find_blank(self):
        # finds the blank row and col
        for row in range(len(self.board)):
            for col in range(len(self.board[0])):
                if self.board[row][col] == 0:
                    return (row, col)

    def move(func):
        # decorator function to add to history everytime a move is made
        # functions with @move will apply this decorator
        def wrapper(self):
            state = Symmetry_puzzle(self.board, self.move_history)
            value = func(state)
            if value:
                return state
            else:
                return None

        return wrapper

    @move
    def add_circle(self):
        for row in range(len(self.board)):
            for col in range(len(self.board)):
                if self.board[row][col] == 0:
                    self.board[row][col] = 1
                    return True
        return False

    @move
    def add_square(self):
        for row in range(len(self.board)):
            for col in range(len(self.board)):
                if self.board[row][col] == 0:
                    self.board[row][col] = 2
                    return True
        return False
    @move
    def add_triangle(self):
        for row in range(len(self.board)):
            for col in range(len(self.board)):
                if self.board[row][col] == 0:
                    self.board[row][col] = 3
                    return True
        return False

  
        # checks if the board is complete
    def objective_state(self):
            # Check if every row and column is a palindrome
            for i in range(5):
                 # Obter a linha i e criar uma cópia sem os valores 0
                row = []
                for x in self.board[i]:
                    if x != 0:
                        row.append(x)

                if row != row[::-1]:
                    return False
                # Obter a coluna i e criar uma cópia sem os valores 0
                col = []
                for j in range(5):
                    if self.board[j][i] != 0:
                        col.append(self.board[j][i])

                if col != col[::-1]:
                    return False
            return True

    def __hash__(self):
        # to be able to use the state in a set
        return hash(str([item for sublist in self.board for item in sublist]))

    def __eq__(self, other):
        # compares the two matrices
        return [item for sublist in self.board for item in sublist] == [item for sublist in other.board for item in sublist]

def print_sequence(sequence):
      print("Steps:", len(sequence) - 1)
      # prints the sequence of states
      for state in sequence:
        for row in state:
            print(row)
        print()


def problems():
      return (
        Symmetry_puzzle([[0,0,0,3,2],[0,0,0,2,0],[1,1,1,0,1],[0,3,3,0,1],[0,0,2,0,0]]),
        Symmetry_puzzle([[1, 3, 6], [5, 2, 0], [4, 7, 8]]),
        Symmetry_puzzle([[1, 6, 2], [5, 7, 3], [0, 4, 8]]),
        Symmetry_puzzle([[5, 1, 3, 4], [2, 0, 7, 8], [
                     10, 6, 11, 12], [9, 13, 14, 15]]),
    )

def bfs(problem):
     # problem(NPuzzleState) - the initial state
     queue = deque([problem]) # can also also use array and pop(0)
     visited = set() # to not visit the same state twice
     while queue:
        node = queue.popleft();

        if node.objective_state():
            return node.move_history
        
        for child in node.children():
            if(child not in visited):
                visited.add(child)
                queue.append(child)
     return None
    
solution = (bfs(problems()[0]))
if solution:
    print_sequence(solution)
else:
    print("Nao foi encontrada soluçao")