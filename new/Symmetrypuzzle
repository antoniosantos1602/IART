from copy import deepcopy
from collections import deque

    # definition of the problem
class Symmetry_puzzle:

        def __init__(self, board, move_history=None):
            # board(list[list[int]]) - the state of the board
            # move_history(list[list[list[int]]]) - the history of the moves up until this state
            self.board = deepcopy(board)

            if move_history is None:
                move_history = []
            
            # create an empty array and append move_history
            self.move_history = [] + move_history + [self.board]
        

        def children(self):
           children = []
           for i in range(len(self.board)):
             for j in range(len(self.board[0])):
                if self.board[i][j] == 0:
                    for k in [1, 2, 3]:
                        child_board = deepcopy(self.board)
                        child_board[i][j] = k
                        
                        child = Symmetry_puzzle(child_board, self.move_history)
                        children.append(child)
           return children

      #  @move
       # def add_circle(self):
        #    for row in range(len(self.board)):
         #       for col in range(len(self.board[0])):
          #          if self.board[row][col] == 0:
           #             self.board[row][col] = 1
            #            return True
            #return False

        #@move
        #def add_square(self):
         #   for row in range(len(self.board)):
          #      for col in range(len(self.board[0])):
           #         if self.board[row][col] == 0:
            #            self.board[row][col] = 2
             #           return True
            #return False
        #@move
        #def add_triangle(self):
         #   for row in range(len(self.board)):
          #      for col in range(len(self.board[0])):
           #         if self.board[row][col] == 0:
            #            self.board[row][col] = 3
             #           return True
            #return False
       
    # objetive state where all rows and columns of the matrix are palindromes.
        def objective_state(self):
                # Check if every row and column is a palindrome
                for i in range(len(self.board)):
                    # Obter a linha i e criar uma cópia sem os valores 0
                    row = []
                    for x in self.board[i]:
                        if x != 0:
                            row.append(x)

                    if row != row[::-1]:
                        return False
                    # Obter a coluna i e criar uma cópia sem os valores 0
                    col = []
                    for j in range(len(self.board)):
                        if self.board[j][i] != 0:
                            col.append(self.board[j][i])

                    if col != col[::-1]:
                        return False
                return True

        def __hash__(self):
            # to be able to use the state in a set
            return hash(str([item for sublist in self.board for item in sublist]))

        def __eq__(self, other):
            # compares the two matrices
            return [item for sublist in self.board for item in sublist] == [item for sublist in other.board for item in sublist]

def print_sequence(sequence):
        print("Steps:", len(sequence) - 1)
        # prints the sequence of states
        for state in sequence:
            for row in state:
                print(row)
            print()

def generate_tree(node, depth):
    if depth == 0:
        return
    children = node.children()
    for child in children:
        print(child.board)
        generate_tree(child, depth - 1)


    #def problems():
    #   return (
    #      Symmetry_puzzle([[1, 2, 3], [5, 0, 6], [4, 7, 8]]),
    #     Symmetry_puzzle([[1, 3, 6], [5, 2, 0], [4, 7, 8]]),
        #    Symmetry_puzzle([[1, 6, 2], [5, 7, 3], [0, 4, 8]]),
        #   Symmetry_puzzle([[5, 1, 3, 4], [2, 0, 7, 8], [
        #               10, 6, 11, 12], [9, 13, 14, 15]]),
    # )

def bfs(problem):
        # problem(NPuzzleState) - the initial state
        queue = deque([problem]) # can also also use array and pop(0)
        visited = set() # to not visit the same state twice
        while queue:
            node = queue.popleft();
            
            if node.objective_state():  
                return node.move_history
            
            for child in node.children():
                if(child not in visited):
                    print(child.board)
                    visited.add(child)
                    queue.append(child)
        return None

problem = Symmetry_puzzle([[0,0,1],
                           [0,2,0],
                           [1,1,1]])

generate_tree(problem,depth=2)

